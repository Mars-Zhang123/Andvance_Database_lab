
<center>

# 实现Storage and Buffer Manager #

</center>

## 问题与解决 ##
- 指针陷阱，由于项目开发采用C++，不可避免地与指针打交道。

## 实验结果 ##
&emsp;&emsp;本次实验中分别对LRU算法和2Q算法进行了系列性能对比测试，主要测试了在data-2w-50w-zipf.txt中的命令输入下，存储缓冲管理器的运行时间、缓存命中率和磁盘IO次数。在相同的算法中，通过改变缓冲区容量`DEFBUFSIZE`为1024、2048和4096，得到了同一个算法在不同缓冲区规模下的性能变化。实验结果绘制图如下：
![](src/hit_rate.png)
&emsp;&emsp;从命中率曲线图得出，在同等规模的缓冲区下，2Q的命中率普遍比LRU更高，LRU算法命中率普遍更早的比2Q算法命中率进入收敛；在随着缓冲区增大，LRU算法和2Q算法的命中率都有一定幅度的增大，同时算法命中率到达收敛所需的访问请求都有一定的增加。
![](src/IO_count.png)
&emsp;&emsp;从磁盘IO曲线图得出，LRU算法和2Q算法的与磁盘IO次数随着页面访问请求呈现线性增加。在同等规模的缓冲区下，2Q算法与磁盘IO次数皆低于LRU；随着缓冲区规模增加，对应算法的总IO次数皆有一定程度的降低。
&emsp;&emsp;在50w个页面请求下，对应算法性能参数表如下：
<div class="center">

|algorithm |    hit rate   |  IO     |cost time(s)|
|:--------:|:-------------:|:-------:|:------:|
| LRU 1024 |     33.91%    | 341,001 |  3.139 |
| LRU 2048 |     41.91%    | 301,827 |  2.811 |
| LRU 4096 |     51.09%    | 256,205 |  2.571 |
| 2Q 1024  |     43.01%    | 286,058 |  3.056 |
| 2Q 2048  |     49.75%    | 252,383 |  2.727 |
| 2Q 4096  |     57.08%    | 215,255 |  2.403 |

</div>
&emsp;&emsp;从表中可以看出在命中率和与磁盘的IO次数性能表现上，2Q全面优于LRU，但是最终运行时间上，2Q并未过多的优于LRU，比如2Q在1024容量的缓存下，虽然命中率和IO次数都优于LRU在2048容量缓存下的性能，但最终的运行时间结果却是前者长于后者。分析其原因，主要由于2Q增加了cold和hot机制虽然使得算法适应力更强，但是同时也增加了额外的维护开销，使得2Q运行时间性能最终表现并未大幅度超越LRU，后续可以优化2Q数据结构和对应维护算法来降低这部分维护额外开销。